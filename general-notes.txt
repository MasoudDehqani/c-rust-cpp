- building VS compiling
preprocessor - compiler - linker 

- C compiler looks for 'main' function to start compilation. This particular function is the entry point of the C program.
- The 'main' function is the entry point of Rust programs too.
- The 'main' function is the entry point of C++ programs too.

- operating system is the caller of the main function ??

- C, Rust and C++ return 0 for successful compilation of the program and return an integer other than 0 for failed compilation

- The role of "return" keyword and semicolon (;) in C, Rust and C++

- statement VS expression
- statement is a type of instruction

- header file in C and C++
- namespace in C++
- object files in C and C++

- This syntax (std::) exists in both Rust and C++

- In C the main function mostly does not take any parameters. But it can take argc and argv as parametes whose valus are provided at runtime by
command-line arguments

- ABI (application binary interface)

- naming convention in C, Rust, and C++ is mostly sanke_case

- screaming snake case -> SCREAMING_SNAKE_CASE
- screaming snake case is used in both C and Rust for naming constants
- for the sake of best practices, naming in C and C++ should avoid using _ or __ for the beginning of the name as this is the convention for
system level (implementation) naming

- object refers to a storage in memory in which values can be stored.
- names of identifiers can be assigned to objects
- the name or identifier bound (bind) to an object is called variable
- values can be assigned to identifiers (names or variables) which altogether produces a variable  

- keyword (reserved identifier or reserved word)

- re-binding (re-assigning) VS shadowing VS mutating of variables
- transformation

- compiling and running are separate in both C and Rust

- When a single operation takes multiple steps, we say the operation is not atomic

- C can integrate assembly language code into its codes. It is possible to write assembly code in C code
- Rust can integrate C codes into its codes

- These are possible in C, but not in Rust:
int var1, var2, var3;
var1 = var2 = var3 = 10;
int x = 1, y = 2, z = 3;

- These are possible in Rust, but not in C:
let x = 1;
let x = 2;
(this is called shadowing in Rust)

- range -> upper and lower limit of some set of data

- decimal number system -> base 10 number system
example:
568 -> 5 * (10**2) + 6 * (10**1) + 8 * (10**0)

- binary number system -> base 2 number system
example:
1001 -> 1 * (2**3) + 0 * (2**2) + 0 * (2**1) + 1 * (2**0)
the binary example above is a 4-bit data

- each digit in each number system has a place value

- range of 4-bit data:
minimum -> 0000 -> 0
maximum -> 1111 -> 15
so range of 4 bit data is -> 0000 to 1111
converting it to decimal -> 0 to 15
- formula to calculate the maximum is -> (2**n) - 1
(n is the number of bits)

- scientific notation -> 10e3 -> 10**3

- In two's complement representation, the range of a 2-byte data (16 bits) is:
unsigned -> 0 to (2**16) - 1 -> 0 to 65535
signed -> -32768 to +32767
the formula for calculating the maximum in signed -> -(2**(n-1)) to (2**(n-1)) - 1
example for 2-byte (16-bit):
-(2**(16-1)) to (2**(16-1)) - 1
-32768 to +32767

- There are 3 ways to represent negative numbers in computer
1. signed magnitude
2. one's (1's) complement
3. two's (2's) complement

Integer types in C and Rust:
- In C, there is only an 'int' type for integers, with some modifiers (short, long, signed, unsigned)
- In Rust, there are separate types for integers (u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, isize, usize)

In a 3-bit unsigned binary number, for example, the maximum value is: 111 witch is 7 in decimal.
Representing 8 in would be 1000 in binary, but since the maximum in our 3-bit number is of
3 bits, the extra bit in the most significant place can't be displayed. So, 8 would be
displayed as 0 in the 3-bit number, 9 would be 1, 10 would be 2 and so on...

- It is equivalent to mod (modulo) function for unsigned int. For example in the 3-bit example, it is mod 8 (mod 2**3):
examples:
8 mod 8 -> 0
9 mod 8 -> 1
10 mod 8 -> 2
formula for n bit unsigned data: mod 2**n

- modulo VS modulus -> modulo is the operator, modulus is a noun which is the result of "x mod y"
- For example clock is mod 12 function -> 13 mod 12 = 1, 14 mod 12 = 2, 15 mod 12 = 3

As in unsigned data the overflow will return back to its minimum (if trying to assign a value more than the maximum), for signed data also
the integer overflow will return back to its minumum. For example in a 4-bit signed int, adding 1 to the maximum which is 7, will set the value to -8.
- Note that trying to assign a value less than the minumum, the cycling will result in the returning back to the maximum value. Example:
let x: u8 = -129 -> 127
in this example we imagine that the value -129 would not be set at compiler time since the compiler rejects it

- Note that the representation of negative integers in both C and Rust is based on the two's complement
- Rust behaves differently in debug mode and release mode regarding integer overflow. In debug mode it is paniced and in release mode
the overflow occurs. Note that this would be the case if the value which is to be stored in the value with the specified type
is not known at compile time. If for example you want to explicitly assign value 128 to a variable with u8 type, the compiler rejects
this, but in C, on the other hand, this would result in a warning (at least in gcc compiler as I tested it)
