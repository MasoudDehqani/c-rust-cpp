- Unix OS first was written in assembly language, then re-written by C language. It was the first use of C.
- Assembly language is not portable. it is different for different machines.
- C language is portable

- C is a procedural language
- procedure or function or subroutine

- high or low in high-level languages or low-level languages refers to the degree of abstraction
- abstraction in programming -> hiding system level details

- C is a middle level language

- C can integrate assembly language code into its codes. It is possible to write assembly code in C code
- Rust can integrate C codes into its codes

- preprocessor directive
- output of preprocessor is expanded source code

- files with .h extension are called header files. header files usually consist of declarations or prototypes

- stdio.h -> standard input/output header file

- C standard library
- C standard library functions VS compiler built-in functions

- building VS compiling

- C compiler looks for 'main' function to start compilation. This particular function is the entry point of the C program.
- The 'main' function is the entry point of Rust programs too.

- Both C and Rust return 0 for successful compilation of the program and return an integer other than 0 for failed compilation

- In C the main function mostly does not take any parameters. But it can take argc and argv as parametes whose valus are provided at runtime by
command-line arguments

- naming convention in both C and Rust is sanke_case

- screaming snake case -> SCREAMING_SNAKE_CASE
- screaming snake case is used in both C and Rust for naming constants

- variables are simply names that point to a memory location
- declaration: announcing the properties of the variable to the compiler

properties of a variable:
- size of the variable (type of the variable)
- name of the variable

- most of the time declaration and the definition will be done at the same time

- compiling and running are separate in both C and Rust

- declarations of functions VS actual definitions of functions

- linker is a program which maps the declarations (prototypes) mentions by preprocessor to the actual code (actual definitions).

- preprocessor, linker

- In C, range of 2 byte int (16 bits):
unsigned -> 0 to (2**16) - 1 -> 0 to 65535
signed -> -32768 to +32767
the formula for calculating the maximum in signed int -> -(2**(n-1)) to (2**(n-1)) - 1
example for 2-byte int (16-bit int):
-(2**(16-1)) to (2**(16-1)) - 1
-32768 to +32767
- these are based on two's complement system

- There are 3 ways to represent negative numbers in computer
1. signed magnitude
2. one's (1's) complement
3. two's (2's) complement

- In C, there is only an 'int' type for integers, with some modifiers (short, long, signed, unsigned)
when short or long is used, the type might be of less or more size (there is no guarantee)
examples for int (note that short and long can be also used for other data types other than int):
using short on a 4-byte int turn it into 2-byte -> short int var1;
using long on a 4-byte int turn it into 8-byte -> long int var2;
- Note that there is no guarantee for short and long modifiers. The only guarantee is:
sizeof(short int) <= sizeof(int) <= sizeof(long int)

- using int, by default it is signed int

- for the sake of best practices, naming in C and C++ should avoid using _ or __ for the beginning of the name as this is the convention for
system level (implementation) naming

- int -> 2 bytes or 4 bytes -> depending on machine

- assigning a value to a variable at the time of definition is called initialization
